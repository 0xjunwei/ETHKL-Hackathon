{
  "language": "Solidity",
  "sources": {
    "contracts/Notary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\ncontract Notary {\n    struct Proof {\n        // Timestamp proof was added to the blockchain\n        uint256 timestamp;\n        // Bytes of Proof Committing into the smart contract\n        string hash;\n    }\n\n    address public immutable i_owner;\n    mapping(address => bool) public notarizers;\n    mapping(string => Proof) public proofs; // document identifier to Proof\n\n    // Saving gas so only showing status change true/false\n    event NotarizerStatusChanged(address indexed _notarizer, bool status);\n    // Emit event when a new proof is added\n    event ProofAdded(\n        string indexed _docHash,\n        string _tslHash,\n        uint256 timestamp\n    );\n\n    constructor() {\n        i_owner = msg.sender;\n    }\n\n    // Typical onlyOwner function to ensure only owner can call\n    modifier onlyOwner() {\n        require(msg.sender == i_owner, \"Not contract owner\");\n        _;\n    }\n    // Only notarizers can add proofs to the contract, having an array can have multiple people within an organization to add instead of a single wallet\n    modifier onlyNotarizer() {\n        require(notarizers[msg.sender], \"Not authorized notarizer\");\n        _;\n    }\n\n    // Allows the owner to add a notarizer\n    function addNotarizer(address _notarizer) public onlyOwner {\n        notarizers[_notarizer] = true;\n        emit NotarizerStatusChanged(_notarizer, true);\n    }\n\n    // removes notarizer function\n    function removeNotarizer(address _notarizer) public onlyOwner {\n        notarizers[_notarizer] = false;\n        emit NotarizerStatusChanged(_notarizer, false);\n    }\n\n    // adds proof as a notarizer\n    // @param _docHash hash of document\n    // @param _tslHash the TLSnotary hash of document with timestamp this was placed\n    function addProof(\n        string memory _docHash,\n        string memory _tslHash\n    ) public onlyNotarizer {\n        require(proofs[_docHash].timestamp == 0, \"Proof already exists!\");\n        proofs[_docHash] = Proof(block.timestamp, _tslHash);\n        emit ProofAdded(_docHash, _tslHash, block.timestamp);\n    }\n\n    // Validates a proof if it exists\n    // @param _docHash hash of the document\n    // @param _tslHash the TLSnotary hash of document to check if it matches the stored proof\n    function verifyProof(\n        string calldata _docHash,\n        string calldata _tslHash\n    ) public view returns (bool) {\n        bytes32 b_docHash = keccak256(abi.encodePacked(proofs[_docHash].hash));\n        bytes32 b_tslHash = keccak256(abi.encodePacked(_tslHash));\n        return b_docHash == b_tslHash;\n    }\n\n    // Get owner of contract\n    function getOwner() public view returns (address) {\n        return i_owner;\n    }\n\n    // check if notarizer of contract\n    function checkNotarizer(address _notary) public view returns (bool) {\n        return notarizers[_notary];\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}